|00 @System &vector $2 &pad $6 &r $2 &g $2 &b $2 &debug $1 &state $1
|10 @Console &vector $2 &read $1 &pad $5 &write $1
|20 @Screen &vector $2 &width $2 &height $2 &auto $1 &pad $1 &x $2 &y $2 &addr $2 &pixel $1 &sprite $1
|80 @Controller &vector $2 &button $1 &key $1
|90 @Mouse &vector $2 &x $2 &y $2 &state $1 &wheel $1
|a0 @File &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

%DEBUG { CR #01 .System/debug DEO }
%HALT { #01 .System/state DEO }
%EMIT { .Console/write DEO }

%DEC2 { #0001 SUB2 }
%NOT2 { #0000 EQU2 }
%GEQ2 { LTH2 NOT2 }

%CR { #0a EMIT }
%SPACE { #20 EMIT }

%C_0 { #30 }
%C_9 { #39 }
%C_: { #3a }
%C_a { #61 }
%C_f { #66 }
%C_{ { #7b }

%K_ESC { #1b }

%null { #00 }
%newline { #0a }
%space { #20 }

|0000
@in $2
@here $2
@dictptr $2
@base $2


|0100
  ;on-key .Controller/vector DEO2
  ;on-console .Console/vector DEO2

  ;tib .in STZ2
  ;memory .here STZ2
  #0010 .base STZ2
  ;Builtin-emit .dictptr STZ2

  ;prompt ;print-str JSR2
BRK


@on-key ( callback )
  .Controller/key DEI
  STHk
  K_ESC NEQ ,&end JCN
    HALT
  &end
BRK


@on-console ( callback )
  .in LDZ2 ;tib/end EQU2 ,&tib-overflow JCN

  .Console/read DEI
  DUP newline EQU ,&newline JCN
  .in LDZ2 STA
  .in ;inc-zptr JSR2
BRK

&newline ( newline -- )
  POP
  #00 .in LDZ2 STA

  ;tib ;interpret JSR2
  LIT 'k LIT 'o EMIT EMIT CR

  ;tib .in STZ2
  ( ;prompt ;print-str JSR2 )
BRK

&tib-overflow
    ;Error/tib-overflow ;print-str JSR2
    HALT
BRK


@inc-zptr ( zaddr -- )
  STHk LDZ2
  INC
  STHr STZ2
JMP2r


@interpret ( *str -- )
  DUP2 ;print-str JSR2 CR
  DUP2 .in STZ2
  ;&word STA2

  &loop
  .in LDZ2 LDA

  DUP space EQU ,&space JCN
  DUP null EQU ,&null JCN

  ( everything else )
  POP
  .in ;inc-zptr JSR2
  ,&loop JMP

&space
  POP
  null .in LDZ2 STA
  .in ;inc-zptr JSR2

  ;&word LDA2 ;eval-word JSR2
  .in LDZ2 ;&word STA2

  ,&loop JMP

&null
  POP
  ;&word LDA2 ;eval-word JSR2
JMP2r
&word $2


@eval-word ( *str -- )
  DUP2 LIT 'W EMIT space EMIT ;print-str JSR2 CR
  DUP2 ;lookup JSR2

  #0000 EQU2 ,&number JCN

  ;execute JSR2
  ,&end JMP

  &number
  ;number JSR2
  ,&error JCN

  ( DUP ;print-short JSR2 CR )
  ;push JSR2

&end
JMP2r

&error
  ;&name ;println JSR2
  DEBUG
  HALT
JMP2r
&name "eval-word 00


@lookup ( *str -- &dictnode )
  STH2
  .dictptr LDZ2

&loop ( *dictnode )
  DUP2 #0000 EQU2 ,&fail JCN

  DUP2 ;dict-name JSR2
  STH2rk
  ;string-equal JSR2 ,&match JCN

  ;dict-link JSR2
  LDA2


  ,&loop JMP

&match
  LIT 'm EMIT CR
  HALT
JMP2r

&fail
  POP2
  POP2r
  LIT 'e EMIT CR
  #0000
  DEBUG
JMP2r


@dict-name ( *dict -- *name )
  INC2
JMP2r

@dict-link ( *dict -- *link )
  LDAk #00 SWP ADD2 ( skip strlen )
  #0002 ADD2 ( skip length byte and null byte )
JMP2r

@push ( u16 -- )
  ( calculate tos )
  ;Wst
  #00 ;Wst/ptr LDA
  ADD2

  DUP2 ;Wst/end GEQ2 ,&stack-overflow JCN
  
  STA2

  ;Wst/ptr LDA INC ;Wst/ptr STA

JMP2r

&stack-overflow
  ;Error/stack-overflow ;println JSR2
  DEBUG
  HALT
JMP2r


@execute ( &dictnode -- )
  ;&name ;println JSR2
  ;Error/todo ;println JSR2
  HALT
JMP2r
&name "execute 00


@emit ( -- )
  ;&name ;println JSR2
  ;Error/todo ;println JSR2
  HALT
JMP2r
&name "emit 00


@exit ( -- )
  ;&name ;println JSR2
  ;Error/todo ;println JSR2
  HALT
JMP2r
&name "exit 00

~string.tal

@prompt
"> 20 00


@Error
&invalid-char "invalid 20 "char: 20 00
&todo "todo 00
&tib-overflow "tib 20 "overflow 00
&stack-overflow "stack 20 "overflow 00


@tib
$ff
&end

@Wst
$fd
&end
&err $1
&ptr $1

@Rst
$fd
&end
&err $1
&ptr $1

@Builtin-emit
&name-length 04
&name "emit 00
&link :Builtin-exit
&code ;emit

@Builtin-exit
&name-length 04
&name "exit 00
&link 0000
&code ;exit

@memory
