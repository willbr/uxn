@number ( *str -- u16 success )
( #30 to #39 is ascii 0 - 9
  #61 to #66 is ascii a - f )

  ( DUP2 ;println JSR2 )

  INC2 ( skip length )

  #0000 STH2

&loop
  LDAk null EQU ,&end JCN

  .base LDZ2 STH2 MUL2r

  ( LDAk EMIT space EMIT LDAk ;print-byte JSR2 CR )

  LDAk DUP #2f GTH SWP #3a LTH AND ,&numeral JCN
  LDAk DUP #60 GTH SWP #67 LTH AND ,&hex JCN
  ,&error JMP

&next
  INC2
  ,&loop JMP

&numeral
  ( LIT 'n EMIT )
  LDAk C_0 SUB 
  #00 SWP STH2 ADD2r
  ,&next JMP

&hex
  ( LIT 'h EMIT )
  LDAk #57 SUB
  #00 SWP STH2 ADD2r
  ,&next JMP

&error
  ;Error/invalid-char ;print-str JSR2
  LDAk EMIT
  CR
  HALT

&end
  POP2
  STH2r
  #00
JMP2r


@string-equal ( *str1 *str2 -- u8 )
(
  LDAk ;print-byte JSR2
  space EMIT
  DUP2 ;print-str JSR2
  space EMIT
  LIT '= EMIT
  space EMIT
  OVR2
  LDAk ;print-byte JSR2
  space EMIT
  ;print-str JSR2
  CR
  )
  STH2

&loop
  LDAk
  STH2rk LDA

  ( DUP2 ;print-short JSR2 CR )

  NEQk ,&fail JCN
  #00 EQU SWP #00 EQU
  AND ,&match JCN

  ( next )
  INC2
  INC2r
  ,&loop JMP


&match
  POP2  ( *str1 )
  POP2r ( *str2 )
  #01
JMP2r

&fail
  POP2  ( c1 c2 )
  POP2  ( *str1 )
  POP2r ( *str2 )
  #00
JMP2r


@print-byte ( byte -- )
	DUP #04 SFT ,&char JSR
	&char ( char -- ) #0f AND DUP #09 GTH #27 MUL ADD #30 ADD #18 DEO
JMP2r


@print-short ( short -- )
  SWP
  ;print-byte JSR2
  ;print-byte JSR2
JMP2r


@print-str ( *str -- )
  INC2
  ,&cond JMP
	&while
		LDAk EMIT
		INC2
    &cond
    LDAk ,&while JCN
	POP2
JMP2r


@println ( *str -- )
  ,print-str JSR
  CR
JMP2r


