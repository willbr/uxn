%mask-immediate { #80 }
%mask-hidden    { #40 }
%mask-length    { #3f }

%NEXT { ;donext JMP2 }


@forth-init
  ;tib .in STZ2
  ;memory .here-pos STZ2
  #10 .base STZ
  ;Builtin-emit .latest STZ2
JMP2r


@e?
  LIT 'e EMIT
  .error LDZ ;print-byte JSR2
  CR
JMP2r


@on-console-forth
  ( check for overflow )
  .in LDZ2 ;tib/end EQU2 ,&tib-overflow JCN

  ( read char )
  .Console/read DEI

  ( DUP EMIT )

  ( check for newline )
  DUP newline EQU ,&newline JCN

  ( store char, and increment pointer )
  .in LDZ2 STA
  .in ;inc-zptr JSR2
  &end
JMP2r


&newline ( newline -- )
  POP
  ( terminal tib with null char )
  null .in LDZ2 STA

  ;interpret JSR2
  .error LDZ #01 ,&error JCN
  ;&done ;println JSR2

  ;tib .in STZ2
  ;prompt ;print-str JSR2
BRK
&done
03 20 "ok 00

&error
BRK
&tib-overflow
    ;Error/tib-overflow ;print-str JSR2
    HALT
BRK


@inc-zptr ( zaddr -- )
  DUP LDZ2
  INC
  ROT STZ2
JMP2r


@read-word ( -- *str )
  .in LDZ2 #0001 SUB2 ;word STA2

&loop
  ( load next char )
  .in LDZ2 LDA
  ( DUP ;print-byte JSR2 space EMIT DUP EMIT CR )

  ( check char )
  DUP space EQU ,&space JCN
  DUP null  EQU ,&null  JCN

  ( everything else )
  POP
  .in ;inc-zptr JSR2
  ,&loop JMP

&space
  POP
  null .in LDZ2 STA
  ;word LDA2
  ,&calc-len JSR
  .in ;inc-zptr JSR2
JMP2r

&null
  POP
&end
  ;word LDA2
  ,&calc-len JSR
JMP2r

&calc-len
  .in LDZ2 ;word LDA2 INC2 SUB2
  NIP
  ;word LDA2 STA
JMP2r


@isnt-immediate ( addr -- b8 )
  LDA mask-immediate AND
  mask-immediate NEQ
JMP2r


@dbg
  .state LDZ ,&c JCN
  LIT 'i EMIT
  ,&next JMP
&c
  LIT 'c EMIT
&next
  space EMIT
  ;print-cstr JSR2
  CR
JMP2r


@interpret ( -- )
  ;tib .in STZ2
  ( CR .in LDZ2 ;print-cstr JSR2 CR )
&loop
  .error LDZ #01 EQU ,&end JCN
  ;read-word JSR2
  ( DUP2 ;dbg JSR2 )

  ( read first char )
  DUP2 INC2 LDA

  ( check for end of line )
  null EQU ;&end JCN2

  DUP2 ;lookup JSR2
  DUP2 #0000 NEQ2 ,&word JCN

  ;interpret-number JSR2

  ;&loop JMP2

&word
  ;interpret-word JSR2
  ;&loop JMP2

&end
JMP2r


@interpret-word ( *str *dict -- )
  NIP2 ( drop str )

  DUP2 ;isnt-immediate JSR2
  .state LDZ
  AND
  ,&compile-word JCN

&execute-word
  ;execute JSR2
JMP2r

&compile-word
  ;dict-code JSR2 LDA2
  ;push JSR2
  ;comma16 JSR2
JMP2r

@interpret-number ( *str #0000 -- )
  POP2
  ;parse-number JSR2
  ,&error JCN

  .state LDZ ,&compile-number JCN

  ( DUP ;print-short JSR2 CR )
  ;push JSR2
JMP2r
&error
  ;Error/unknown-word ;println JSR2
  #01 .error STZ
JMP2r

&compile-number
  ;lit16
  ;push JSR2
  ;comma16 JSR2
  ;push JSR2
  ;comma16 JSR2
JMP2r


@lookup ( *str -- &dictnode )
  ( DUP2 ;print-str JSR2 CR )
  STH2

  .latest LDZ2

&loop ( *dictnode )
  DUP2 #0000 EQU2 ,&end JCN

  DUP2
  ( skip link and length )
  #0003 ADD2
  ( DUP2 ;print-cstr JSR2 CR )

  STH2rk
  LDA
  STH2rk
  INC

  ( DUP2 ;print-cstr JSR2 CR )
  ;memcmp JSR2

  ,&match JCN

&next
  LDA2
  ,&loop JMP

&match
  ( ;&s-matched ;println JSR2 )
&end
  POP2r
JMP2r
&s-lookup 07 "lookup 20 00
&s-matched 07 "matched 00


@dict-code ( *dict -- *link )
ere
debug
  LDAk
  mask-length AND
  #00 SWP ADD2 ( skip strlen )
  #0004 ADD2 ( skip length byte, null byte and link field )
JMP2r


@tos ( -- )
  ;Wst
  #00 ;Wst/ptr LDA
  ADD2
JMP2r


@tos-return ( -- )
  ;Rst
  #00 ;Rst/ptr LDA
  ADD2
JMP2r


@push ( u16 -- )
  ( DUP2 ;print-short JSR2 CR )
  ;tos JSR2

  DUP2 ;Wst/end GEQ2 ,&stack-overflow JCN

  STA2

  ;Wst/ptr LDA #02 ADD ;Wst/ptr STA
JMP2r

&stack-overflow
  ;Error/stack-overflow ;println JSR2
  HALT
JMP2r


@pop ( -- u16 )
  ( calculate tos )
  ;tos JSR2

  DUP2 ;Wst EQU2 ,&stack-underflow JCN

  #0002 SUB2
  LDA2

  ;Wst/ptr LDA #02 SUB ;Wst/ptr STA
JMP2r

&stack-underflow
  ;Error/stack-underflow ;println JSR2
  HALT
JMP2r


@execute ( *node -- )
  LIT 'x EMIT space EMIT
  DUP2 INC2 ;print-cstr JSR2 CR

  (
  ere
  DUP2 ;print-short JSR2 CR
  ;Builtin-add ;print-short JSR2 CR
  )

  ;dict-code JSR2

  LDA2

  (
  ere
  DUP2 ;print-short JSR2 CR
  ;add ;print-short JSR2 CR
  )

  JSR2
JMP2r


@donext
  ere
  debug
  JMP2r


@dup ( -- )
  ;pop JSR2
  DUP2
  ;push JSR2
  ;push JSR2
  NEXT

@print-tos ( -- )
  ;pop JSR2
  ;print-short JSR2
  NEXT


@add ( -- )
  ;pop JSR2
  ;pop JSR2
  ADD2
  ;push JSR2
  NEXT


@minus ( -- )
  ;pop JSR2
  ;pop JSR2
  SWP2
  SUB2
  ;push JSR2
  NEXT

@mult ( -- )
  ;pop JSR2
  ;pop JSR2
  MUL2
  ;push JSR2
  NEXT


@div ( -- )
  ;pop JSR2
  ;pop JSR2
  SWP2
  DIV2
  ;push JSR2
  NEXT


@emit ( -- )
  ;pop JSR2
  ( DUP2 ;print-short JSR2 CR )
  ( DUP2 #0020 LTH2 ,&error JCN )
  DUP2 #007e GTH2 ,&error JCN

  EMIT
  POP

  NEXT

&error
  ;print-short JSR2 space EMIT
  ;&not-ascii ;println JSR2
  HALT
JMP2r
&not-ascii 09 "not-ascii 00


@lit16 ( -- )
  INC2 INC2
  LDA2k
  ;push JSR2
  NEXT


@docol ( -- )
  ;&name ;println JSR2
  ;Error/todo ;println JSR2
  HALT
JMP2r
&name 05 "docol 00


&stack-underflow
  ;Error/stack-underflow ;println JSR2
  HALT
JMP2r


@exit ( -- )
  STH2r
  .nextp STZ2
  NEXT


@print-stack ( -- )
  ( calculate tos )
  ;Wst
  #00 ;Wst/ptr LDA
  ADD2
  STH2
  ;Wst

&loop
  DUP2 STH2rk EQU2 ,&end JCN
  LDA2k ;print-short JSR2
  space EMIT
  #0002 ADD2
  ,&loop JMP

&end
  POP2
  POP2r
JMP2r


@colon ( -- )
  ;read-word JSR2
  ( LIT '# EMIT space EMIT DUP2 ;print-str JSR2 CR )

  ( check fo null string )
  LDAk #00 EQU ,&error JCN

  ;create-word JSR2
  ;mark-hidden JSR2

  ;docol
  ;push JSR2
  ;comma16 JSR2

  true .state STZ
JMP2r
&error
  ;Error/missing-word ;println JSR2
JMP2r


@create-word ( *str -- )
  ( CR LIT 'c EMIT LIT 'w EMIT space EMIT DUP2 ;println JSR2 )
  .here-pos LDZ2 STH2 ( store new latest )

  LDAk #00 SWP
  ;push JSR2
  ;comma8 JSR2

  LDAk INC STH

&loop
  INC2
  ( LDAk ;debug-ascii JSR2 )
  LDAk #00 SWP
  ;push JSR2
  ;comma8 JSR2
  STHr #01 SUB STHk
  #00 EQU ,&end JCN
  ,&loop JMP

&end
  POP2
  POPr

  ( $2 link )
  .latest LDZ2
  ;push JSR2
  ;comma16 JSR2

  STH2r .latest STZ2
JMP2r

@mark-hidden
  .latest LDZ2 LDA
  mask-hidden ORA
  .latest LDZ2 STA
JMP2r


@clear-hidden
  .latest LDZ2 LDA
  mask-hidden EOR
  .latest LDZ2 STA
JMP2r


@semi-colon
  ;clear-hidden JSR2

  ;exit
  ;push JSR2
  ;comma16 JSR2

  false .state STZ
JMP2r


@push-here
  .here-pos LDZ2
  ;push JSR2
JMP2r

@inc-here8
  .here-pos LDZ2
  INC2
  .here-pos STZ2
JMP2r

@inc-here16
  .here-pos LDZ2
  INC2
  INC2
  .here-pos STZ2
JMP2r

@peek16
  ;pop JSR2
  DUP2 ;print-short JSR2 CR
  LDA2
  DUP2 ;print-short JSR2 CR
  ;push JSR2
JMP2r

@poke16
  ;pop JSR2
  ;pop JSR2
  SWP2
  STA2
  NEXT

@peek8
  #00
  ;pop JSR2
  LDA
  ;push JSR2
  NEXT

@poke8
  ;pop JSR2
  ;pop JSR2
  NIP ROT ROT
  STA
  NEXT

@comma16
  ;push-here JSR2
  ;poke16 JSR2
  ;inc-here16 JSR2
  NEXT

@comma8
  ;push-here JSR2
  ;poke8 JSR2
  ;inc-here8 JSR2
  NEXT


~string.tal

@prompt
00 "> 20 00


@Error
&invalid-char    00 "invalid 20 "char: 20 00
&todo            00 "todo 00
&tib-overflow    00 "tib 20 "overflow 00
&stack-overflow  00 "stack 20 "overflow 00
&stack-underflow 00 "stack 20 "underflow 00
&unknown-word    00 "unknown-word 00
&missing-word    00 "missing-word 00


$1
@tib
$ff
&end

@Wst
$fd
&end
&err $1
&ptr $1

@Rst
$fd
&end
&err $1
&ptr $1

~dict.tal

@memory

|0000
@in $2
@word $2
@here-pos $2
@latest $2
@base $1
@state $1
@nextp $2
@error $1



