( *str
  $1 len
  $? null terminated string
)

(
  TODO

  comma
    push here
    poke16
    here += 2
  commaByte
    push here
    poke8
    here += 1
  word
    len = readword
      push 1
      push len
  find
    pop len
    pop addr
    ret = findword
    push ret

  getcfa
  cfa
  exit
  lit
  docol
  word
  find

  docreate
    word
    create-word

  colon
    docreate
    push docol
    comma
    hide
    state = 1
  semicolon
    push doexit
    comma
    hida
    state = 0
  tick
)


@forth-init
  ;tib .in STZ2
  ;memory .here-pos STZ2
  #0010 .base STZ2
  ;Builtin-emit .dictptr STZ2

  ;prompt ;print-str JSR2
JMP2r


@on-console-forth
  .in LDZ2 ;tib/end EQU2 ,&tib-overflow JCN

  .Console/read DEI
  DUP newline EQU ,&newline JCN
  .in LDZ2 STA
  .in ;inc-zptr JSR2
JMP2r


&newline ( newline -- )
  POP
  null .in LDZ2 STA

  ;interpret JSR2
  ;&done ;println JSR2

  ;tib .in STZ2
  ;prompt ;print-str JSR2
BRK
&done
20 "ok 00

&tib-overflow
    ;Error/tib-overflow ;print-str JSR2
    HALT
BRK


@inc-zptr ( zaddr -- )
  STHk LDZ2
  INC
  STHr STZ2
JMP2r


@read-word ( -- *str )
  .in LDZ2 #0001 SUB2 ;word STA2

&loop
  .in LDZ2 LDA
  ( DUP ;print-byte JSR2 space EMIT DUP EMIT CR )

  DUP space EQU ,&space JCN
  DUP null  EQU ,&null  JCN

  ( everything else )
  POP
  .in ;inc-zptr JSR2
  ,&loop JMP

&space
  POP
  null .in LDZ2 STA
  ;word LDA2
  ,&calc-len JSR
  .in ;inc-zptr JSR2
JMP2r

&null
  POP
&end
  ;word LDA2
  ,&calc-len JSR
JMP2r

&calc-len
  .in LDZ2 ;word LDA2 INC2 SUB2
  NIP
  ;word LDA2 STA
JMP2r


@interpret ( -- )
  ;tib .in STZ2
&loop
  ;read-word JSR2
  DUP2 INC2 LDA #00 EQU ,&end JCN ( end of line )
  ( LIT 'i EMIT space EMIT DUP2 ;print-str JSR2 CR )
  ( ,&loop JMP )

  DUP2 ;lookup JSR2
  DUP2 #0000 EQU2 ,&number JCN

  .compiling LDZ ,&compile-word JCN

  ;execute JSR2
  ,&loop JMP

&compile-word
  ,&loop JMP

&number
  POP2
  ;number JSR2
  ,&error JCN

  .compiling LDZ ,&compile-number JCN

  ( DUP ;print-short JSR2 CR )
  ;push JSR2
  ,&loop JMP

&compile-number
  ;&loop JMP2

&end
JMP2r
&error
  ;Error/unknown-word ;println JSR2
JMP2r


@lookup ( *str -- &dictnode )
  STH2
  .dictptr LDZ2

&loop ( *dictnode )
  DUP2 #0000 EQU2 ,&end JCN

  DUP2
  ( LIT 'l EMIT LIT 'u EMIT space EMIT DUP2 ;println JSR2 )
  STH2rk
  ;string-equal JSR2 ,&end JCN

  ;dict-link JSR2
  LDA2

  ,&loop JMP

&end
  POP2r
JMP2r


@dict-link ( *dict -- *link )
  LDAk #00 SWP ADD2 ( skip strlen )
  #0002 ADD2 ( skip length byte and null byte )
JMP2r

@dict-code ( *dict -- *link )
  LDAk #00 SWP ADD2 ( skip strlen )
  #0004 ADD2 ( skip length byte, null byte and link field )
JMP2r


@tos ( -- )
  ;Wst
  #00 ;Wst/ptr LDA
  ADD2
JMP2r


@push ( u16 -- )
  ( DUP2 ;print-short JSR2 CR )
  ;tos JSR2

  DUP2 ;Wst/end GEQ2 ,&stack-overflow JCN
  
  STA2

  ;Wst/ptr LDA #02 ADD ;Wst/ptr STA
JMP2r

&stack-overflow
  ;Error/stack-overflow ;println JSR2
  HALT
JMP2r


@pop ( -- u16 )
  ( calculate tos )
  ;tos JSR2

  DUP2 ;Wst EQU2 ,&stack-underflow JCN

  #0002 SUB2
  LDA2

  ;Wst/ptr LDA #02 SUB ;Wst/ptr STA
JMP2r

&stack-underflow
  ;Error/stack-underflow ;println JSR2
  HALT
JMP2r


@execute ( &dictnode -- )
  ;dict-code JSR2
  LDA2 JSR2
JMP2r


@dup ( -- )
  ;pop JSR2
  DUP2
  ;push JSR2
  ;push JSR2
JMP2r

@dot ( -- )
  ;pop JSR2
  ;print-short JSR2
JMP2r


@add ( -- )
  ;pop JSR2
  ;pop JSR2
  ADD2
  ;push JSR2
JMP2r


@minus ( -- )
  ;pop JSR2
  ;pop JSR2
  SWP2
  SUB2
  ;push JSR2
JMP2r

@mult ( -- )
  ;pop JSR2
  ;pop JSR2
  MUL2
  ;push JSR2
JMP2r


@div ( -- )
  ;pop JSR2
  ;pop JSR2
  SWP2
  DIV2
  ;push JSR2
JMP2r


@emit ( -- )
  ;pop JSR2
  ( DUP2 ;print-short JSR2 CR )
  ( DUP2 #0020 LTH2 ,&error JCN )
  DUP2 #007e GTH2 ,&error JCN

  EMIT
  POP

JMP2r

&error
  ;print-short JSR2 space EMIT
  ;&not-ascii ;println JSR2
  HALT
JMP2r
&not-ascii "not-ascii 00


@exit ( -- )
  ;&name ;println JSR2
  ;Error/todo ;println JSR2
  HALT
JMP2r
&name "exit 00


@print-stack ( -- )
  ( calculate tos )
  ;Wst
  #00 ;Wst/ptr LDA
  ADD2
  STH2
  ;Wst

&loop
  DUP2 STH2rk EQU2 ,&end JCN
  LDA2k ;print-short JSR2
  space EMIT
  #0002 ADD2
  ,&loop JMP

&end
  POP2
  POP2r
JMP2r


@colon
  ;read-word JSR2
  ( LIT '# EMIT space EMIT DUP2 ;println JSR2 )
  LDAk #00 EQU ,&error JCN
  ( LIT '# EMIT space EMIT DUP2 ;println JSR2 )
  ;create-word JSR2
  POP2
  true .compiling STZ
JMP2r
&error
  ;Error/missing-word ;println JSR2
JMP2r


@create-word ( *str len -- )
CR LIT 'c EMIT LIT 'w EMIT space EMIT DUP2 ;println JSR2
debug
  .here-pos LDZ2 STH2k ( store new dictptr )

  ( $2 link )
  .dictptr LDZ2
  ;push JSR2
  ;comma JSR2

  STH2r .dictptr STZ2
JMP2r


@semi-colon
  ;&name todo
  false .compiling STZ
JMP2r
&name "semi-colon 00


@push-here
  .here-pos LDZ2
  ;push JSR2
JMP2r

@inc-here
  .here-pos LDZ2
  INC2
  .here-pos STZ2
JMP2r

@peek16
  ;pop JSR2
  DUP2 ;print-short JSR2 CR
  LDA2
  DUP2 ;print-short JSR2 CR
  ;push JSR2
JMP2r

@poke16
  ;pop JSR2
  ;pop JSR2
  SWP2
  STA2
JMP2r

@peek8
  #00
  ;pop JSR2
  LDA
  ;push JSR2
JMP2r

@poke8
  ;pop JSR2
  ;pop JSR2
  #00ff AND2
  SWP2
  STA2
JMP2r

@comma
  ;push-here JSR2
  ;poke16 JSR2
  ;inc-here JSR2
JMP2r

~string.tal

@prompt
00 "> 20 00


@Error
&invalid-char    00 "invalid 20 "char: 20 00
&todo            00 "todo 00
&tib-overflow    00 "tib 20 "overflow 00
&stack-overflow  00 "stack 20 "overflow 00
&stack-underflow 00 "stack 20 "underflow 00
&unknown-word    00 "unknown-word 00
&missing-word    00 "missing-word 00


$1
@tib
$ff
&end

@Wst
$fd
&end
&err $1
&ptr $1

@Rst
$fd
&end
&err $1
&ptr $1

@Builtin-emit
&name-length 04
&name "emit 00
&link :Builtin-exit
&code :emit

@Builtin-exit
&name-length 04
&name "exit 00
&link :Builtin-dot
&code :exit

@Builtin-dot
&name-length 01
&name ". 00
&link :Builtin-add
&code :dot

@Builtin-add
&name-length 01
&name "+ 00
&link :Builtin-minus
&code :add

@Builtin-minus
&name-length 01
&name "- 00
&link :Builtin-mult
&code :minus

@Builtin-mult
&name-length 01
&name "* 00
&link :Builtin-div
&code :mult

@Builtin-div
&name-length 01
&name "/ 00
&link :Builtin-dup
&code :div

@Builtin-dup
&name-length 03
&name "dup 00
&link :Builtin-print-stack
&code :dup

@Builtin-print-stack
&name-length 02
&name ".s 00
&link :Builtin-colon
&code :print-stack

@Builtin-colon
&name-length 01
&name ": 00
&link :Builtin-semi-colon
&code :colon

@Builtin-semi-colon
&name-length 01
&name "; 00
&link :Builtin-here
&code :semi-colon

@Builtin-here
&name-length 04
&name "here 00
&link :Builtin-peek16
&code :push-here

@Builtin-peek16
&name-length 01
&name "@ 00
&link :Builtin-poke16
&code :peek16

@Builtin-poke16
&name-length 01
&name "! 00
&link 0000
&code :poke16

@Builtin-peek8
&name-length 01
&name "c@ 00
&link :Builtin-poke8
&code :peek8

@Builtin-poke8
&name-length 01
&name "c! 00
&link :Builtin-comma
&code :poke8

@Builtin-comma
&name-length 01
&name ", 00
&link 0000
&code :comma

@memory

|0000
@in $2
@word $2
@here-pos $2
@dictptr $2
@base $2
@compiling $1



